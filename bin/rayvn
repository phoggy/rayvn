#!/usr/bin/env bash
# shellcheck disable=SC2155
# shellcheck disable=SC2120

if ! (( BASH_VERSINFO[0] > 5 || (BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] >= 3) )); then
    echo -e "\033[0;31mðŸ”º rayvn requires bash version 5.2+, found ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}.${BASH_VERSINFO[2]}\033[0m"
    exit 1
fi

usage() {
    echo
    show bold "Manage shared bash libraries and executables."
    echo
    show "Usage:" bold "rayvn" plain "COMMAND [PROJECT] [PROJECT...] <options>"
    echo
    echo "Commands"
    echo
    echo "    test              Run tests."
    echo "    theme             Select theme."
    echo "    new TYPE NAME     Create a new project/script/library/test with the specified NAME."
    echo "    libraries         List libraries."
    echo "    functions         List public functions."
    echo "    dependencies      Assert that dependencies are satisfied."
    echo "    register          Register a project."
    echo "    release           Create a new release."
    echo
    echo "Use COMMAND --help for any additional details. PROJECT defaults to 'rayvn' if not specified."
    echo
    echo "Options:"
    echo
    echo "    -h, --help        Print this help message and exit."
    echo "    -v                Print the version and exit."
    echo "    --version         Print the version with release date and exit."
    echo
    bye "${@}"
}

main() {
    init "${@}"
    ${command} "${args[@]}"
    echo
}

init() {
    declare -g debugCommand=()
    declare -g debugOptions=()
    declare -g command=
    declare -g projects=()
    declare -g args=()
    declare -g gitHubRepo
    declare -gAi flags=()
    upOptions=()

    # process arguments

    while (( $# )) && [[ -z ${command} ]]; do
        case "${1}" in
            test) parseArgs true runTests "${@:2}" ;;
            theme) parseArgs false theme "${@:2}" ;;
            new | create) parseArgs false create "${@:2}" ;;
            projects) parseArgs true listProjects "${@:2}" ;;
            libraries) parseArgs true listLibraries "${@:2}" ;;
            functions) parseArgs true listFunctions "${@:2}" ;;
            dependencies) parseArgs true projectDependencies "${@:2}" ;;
            register) parseArgs false registerProject "${@:2}" ;;
            release) parseArgs true releaseProject "${@:2}" ;;
            --debug) debugCommand=('--debug') ;debugOptions=('showOnExit') ;;
            --debug-new) debugCommand=('--debug-new') ;debugOptions=('clearLog' 'showOnExit') ;;
            --debug-out) debugCommand=('--debug-out') ;debugOptions=('tty' "${ tty; }") ;;
            --debug-tty) shift; debugCommand=('--debug-tty' "${1}") ;debugOptions=('tty' "${1}") ;;
            -v) printVersion; exit 0 ;;
            --version) printVersion true; exit 0 ;;
            -h | --help | help) command='usage' ;;
            -*) command='usage'; args=("Unknown option:" "${1}") ;;
            *) command='usage'; [[ -n ${1} ]] && args=("Unknown command:" "${1}");;
        esac
        shift
    done

    # Boot rayvn, adding any additional projects, then load core
    source rayvn.up "${upOptions[@]}" 'rayvn/core'

    [[ -n ${command} ]] || usage
    [[ -n "${debugOptions}" ]] && setDebug "${debugOptions[@]}"
}

SECTION="--+-+-----+-++(-++(---++++(---+( ARGUMENT PARSING )+---)++++---)++-)++-+------+-+--"

parseArgs() {
    local add="${1}"
    command="${2}"
    shift; shift
    while (( ${#} > 0 )); do
        case "${1}" in
            -h | --help) flags+=(['help']=1) ;;
            -q | --quiet) flags+=(['quiet']=1) ;;
            --assert) flags+=(['assert']=1) ;;
            --debug) debugOptions=('showOnExit') ;;
            --debug-new) debugOptions=('clearLog' 'showOnExit') ;;
            --debug-out) debugOptions=('tty' "${ tty; }") ;;
            --debug-tty) shift; debugOptions=('tty' "${1}") ;;
            --repo) shift; gitHubRepo="${1}";;
            -*) args+=("${1}") ;;
            *)  if [[ ${add} == true ]]; then
                addIfRayvnExecutable "${1}" || args+=("${1}")
            else
                args+=("${1}")
            fi ;;
        esac
        shift
    done
}

theme() {
    require 'rayvn/theme'
    setTheme
}

addIfRayvnExecutable() {
    [[ ${command} == 'create' ]] && return 1
    local name="${1}"
    local path root rayvnPkgFile
    path="${ which "${name}"; }"
    if [[ -n "${path}" ]]; then

        # Get root directory

        path="${ realpath "${path}"; }"
        path="${path%/}"  # normalize trailing slash
        path="${path%/*}" # strip last component
        root="${path%/*}" # and again to reach root

        # See if there is a rayvn.pkg file

        rayvnPkgFile="${root}/rayvn.pkg"
        if [[ -f ${rayvnPkgFile} ]]; then
            addProject "${name}=${root}"
            return 0
        fi
    fi
    return 1
}

addProject() {
    local projectName="${1%%=*}"
    local project="${1}"
    projects+=("${projectName}")
    [[ ${projectName} == rayvn ]] && return 0
    upOptions+=("--add" "${project}")
}

assertSingleProject() {
    (( ${#projects[@]} > 1 )) && fail "only one project name is supported"
}

ensureAtFront() {
    local -n arrayRef="${1}"
    local first="${2}"
    local newArray=("${first}")
    declare -i seen=0

    for element in "${arrayRef[@]}"; do
        if [[ "${element}" == "${first}" ]] && (( ! seen )); then
            seen=1
        else
            newArray+=("${element}")
        fi
    done

    arrayRef=("${newArray[@]}")
}

SECTION="--+-+-----+-++(-++(---++++(---+( COMMANDS )+---)++++---)++-)++-+------+-+--"

printUsage() {
    usage
}

create() {
    if (( flags['help'] )); then
        echo "rayvn new project|script|library NAME"
    else
        local type=${args[0]}
        local name=${args[1]}
        local command=
        [[ -n "${type}" ]] || bye "one of 'project', 'script' 'library' or 'test' required"
        case ${type} in
            project | script | library | test) ;;
            *) bye "unknown type: ${type}"
        esac
        [[ -n "${name}" ]] || bye "name required"
        local gitRoot=${ git rev-parse --show-toplevel 2>/dev/null; } || gitRoot=''
        local templateDir="${rayvnHome}/templates"
        args=("${args[@]:3}")

        case ${type} in
            project) createProject;;
            script) createScript ;;
            library) createLibrary ;;
            test) createTest ;;
        esac
    fi
}

projectDependencies() {
    if (( flags['help'] )); then
        echo "rayvn dependencies [PROJECT] [--assert] [-q | --quiet]"
    else
        require 'rayvn/dependencies'
        ensureAtFront projects rayvn
        if (( flags['assert'] )); then
            assertProjectDependencies projects flags['quiet']
        else
            listProjectDependencies projects flags['quiet']
        fi
    fi
}

registerProject() {
    if (( flags['help'] )); then
        echo "rayvn register PROJECT [--remove] "
    else
        require 'rayvn/central'
        local projectName=${args[0]}
        [[ -n ${projectName} ]] || fail "project name required"
        local projectUrl repoName
        projectUrl="${ git remote get-url origin; }" || fail
        projectUrl="${projectUrl%.git}"
        repoName=${ baseName ${projectUrl}; }
        [[ ${projectName} == "${repoName}" ]]
        registerProjectOnRayvnCentral "${projectName}" || fail
    fi
}

releaseProject() {
    if (( flags['help'] )); then
        echo "rayvn release [PROJECT | --repo 'my-account/my-repo'] VERSION "
    else
        local version=
        if (( ${#projects[@]} )); then
            assertSingleProject
            version="${args[0]}"
        elif (( ${#args[@]} == 1 )); then
            projects=(rayvn)
            version="${args[0]}"
        else
            projects=("${args[0]}")
            version="${args[1]}"
        fi

        [[ -n ${version} ]] || fail "version required"

        local ghRepo="${gitHubRepo}"
        if [[ -z ${ghRepo} ]]; then
            local project="${projects[0]}"
            case "${project}" in
                rayvn) ghRepo='phoggy/rayvn' ;;
                valt) ghRepo='phoggy/valt' ;;
                wardn) ghRepo='phoggy/wardn' ;;
                *) fail "Please specify project using GitHub repo format: --repo 'my-account/my-repo'."
            esac
        fi

        require 'rayvn/release'
        release "${ghRepo}" "${version}"
    fi
}


listProjects() {
    forEachProject _printProject "${args[@]}"
}

_printProject() {
    local projectName="${1}"
    local projectRoot="${2}"
    echo "project '${projectName}' -> ${projectRoot}"
}

listLibraries() {
    forEachProject _printLibraries "${1}"
}

_printLibraries() {
    local project="${1}"
    echo "project '${project}'"
    forEachLibrary "${project}" _printProjectLibrary
}

_printProjectLibrary() {
    local library="${2}"
    local file="${3}"
    echo "    ${library} -> ${file}"
}

listFunctions() {
    local sourceName
    local functions=()
    local function
    local suffix
    for sourceName in "${_rayvnSources[@]}"; do
        echo
        show bold "${sourceName} functions"
        echo
        getFunctions functions "${sourceName}"
        functions=(${ printf '%s\n' "${functions[@]}" | sort; })
        for function in "${functions[@]}"; do
            if declare -pF "${functionName}" 2> /dev/null | grep -q "declare -fr"; then
                suffix=
            else
                suffix="${ show bold red " [NOT READONLY!]" ;}"
            fi

            if [[ ${function} == _* ]]; then
                show italic red "    ${function}" "${suffix}"
            else
                echo "    ${function}" "${suffix}"
            fi
        done
        functions=()
    done
}

getFunctions() {
    local -n arrayRef="${1}"
    local filter="${2:-''}"
    local applyFilter=${ [[ ${filter} == '' ]] && echo 0 || echo 1; }
    local source
    for functionName in "${!_rayvnFunctionSources[@]}"; do
        source="${_rayvnFunctionSources[${functionName}]}"
        if (( applyFilter )); then
            if [[ ${source} == "${filter}" ]]; then
                arrayRef+=("${functionName}")
            fi
        else
            arrayRef+=("${functionName}")
        fi
    done
}

forEachProject() {              # TODO: this pattern is a pain. Replace with getProjects()
    local command="${1}"
    local arguments=("${@:2}")
    local projectRoot
    for project in "${!_rayvnProjects[@]}"; do
        if [[ "${project}" == *"::project"  ]]; then
            project="${project%::project}"
            projectRoot="${_rayvnProjects[${project}::project]}"
            "${command}" "${project}" "${projectRoot}" "${arguments}"
        fi
    done
}

forEachLibrary() {              # TODO: this pattern is a pain. Replace with getLibraries() with optional project filter.
    local project="${1}"
    local command="${2}"
    local arguments=("${@:3}")
    local libraryRoot="${_rayvnProjects[${project}::library]}"
    [[ -n ${libraryRoot} ]] || fail "no libraries found for '${project}' project"
    for file in "${libraryRoot}"/*.sh; do
        [[ -e ${file} ]] || fail "no libraries found for '${project}' at ${libraryRoot}"
        local fileName="${ basename "${file}"; }"
        local library="${fileName%.*}"
        "${command}" "${project}" "${library}" "${file}" "${arguments}"
    done
}

printVersion() {
    local verbose="${1:-}"
    if ! declare -p _rayvnProjects &> /dev/null; then
        source rayvn.up 'rayvn/core'
    fi
    projectVersion rayvn "${verbose}"
}

_printLibrary() {
    local projectName="${1}"
    local libraryName="${2}"
    local libraryRoot="${3}"
    echo "${projectName}/${libraryName} -> ${libraryRoot}"
}

runTests() {
    if (( flags['help'] )); then
        echo "rayvn test [PROJECT] [TEST-NAME]"
    else
        require 'rayvn/spinner' 'rayvn/prompt'
        echo

        # Make sure we can ctrl-c out
        unset rayvnNoExitOnCtrlC

        # Setup logging

        local testLogDir="${ configDirPath tests; }" || fail
        ensureDir "${testLogDir}" || fail
        rm "${testLogDir:?}"/* 2> /dev/null # remove any existing logs
        local failedTestsFile="${ tempDirPath failed-tests; }"

        # Ensure rayvn is first in the projects list

        if [[ ! " ${projects[*]} " =~ " rayvn " ]]; then
            projects=("rayvn" "${projects[@]}")
        fi

        # Create map for project messages

        local -A skipTestNames=()
        local matchArg noMatchMsg=''
        for matchArg in "${args[@]}"; do
            (( ${#noMatchMsg} > 0)) && noMatchMsg+=' or '
            noMatchMsg+="'${matchArg}'"
        done

        # Find all test files

        local testNames=()
        local testFiles=()
        local testFileNames=()
        forEachProject collectProjectTests
        local maxIndex=${#testNames[@]}

        # Find maximum project and test name lengths to find result column

        local maxProjectNameLength="${ maxArrayElementLength projects; }"
        local maxTestNameLength="${ maxArrayElementLength testNames; }"
        local resultColumn=$(( maxProjectNameLength + 1 + maxTestNameLength + 6 ))
        debugVars maxProjectNameLength maxTestNameLength resultColumn

        # Run tests for all specified projects

        forEachProject runProjectTests

        # Read failed test names from temp file

        local failedTestLogNames=()
        if [[ -s "${failedTestsFile}" ]]; then
            mapfile -t failedTestLogNames < "${failedTestsFile}"
        fi
        local failedTestCount=${#failedTestLogNames[@]}

        # Any error logs?

        if (( failedTestCount && ! inContainer )); then
            local answer i logFile
            echo
            for (( i=0; i < failedTestCount; i++ )); do
                confirm "View ${failedTestLogNames[${i}]}?" yes no answer || bye
                if (( answer == 0 )); then
                    local logFile="${testLogDir}/${failedTestLogNames[${i}]}"
                    echo
                    cat "${logFile}"
                    echo
                fi
            done
        fi
    fi
}

collectProjectTests() {
    local project="${1}"
    local projectRoot="${2}"
    local testDir="${projectRoot}/test"
    local testName
    local hasMatchArg=${#args[@]}

    if [[ -d "${testDir}" ]]; then
        local file fileName testName
        local files=("${testDir}"/test-*.sh)

        for file in "${files[@]}"; do
            fileName="${ basename ${file}; }"
            testName="${fileName#test-}"
            testName="${testName%.sh}"

            # Add them all

            testNames+=("${testName}")
            testFileNames+=("${fileName}")
            testFiles+=("${file}")
            skipTestNames+=([${testName}]=0)

            if (( hasMatchArg )); then
                local matchArg skip=1
                for matchArg in "${args[@]}"; do
                    if [[ "${testName}" =~ ${matchArg} ]]; then
                        skip=0; break
                    fi
                done
                (( skip )) && skipTestNames+=(["${testName}"]=1)
            fi
        done
    fi
}

runProjectTests() {
    local project="${1}"
    local projectRoot="${2}"
    local testDir="${projectRoot}/test"
    local testName testFile promptIndex skip
    local indices=()

    for (( i=0; i < maxIndex; i++ )); do
        if [[ ${testFiles[${i}]} == ${testDir}/* ]]; then
            indices+=("${i}")
        fi
    done

    if (( ${#indices} )); then
        for i in "${indices[@]}"; do
            testName="${testNames[${i}]}"
            testFile="${testFiles[${i}]}"
            skip="${skipTestNames["${testName}"]}"
            if (( skip )); then
                skipTest "skipped: does not match ${noMatchMsg}"
            elif (( inContainer )) && [[ ${testFile} == *linux-*.sh ]]; then
                skipTest "skipped: linux test in linux container"
            else
                runTest "${testName}" "${testFile}" "${failedTestsFile}"
            fi
        done
    else
        noTests
    fi
}

noTests() {
    local padLen=$(( resultColumn - ${#project} )) # only project name, no 'test' constant
    local padding="${ padSpaces ${padLen}; }"
    show bold "${project}" plain "${padding}" dim warning 'â—ˆ' plain dim "no tests" # â—ˆ âž– ï¹£
}

skipTest() {
    local message="${1}"
    local padLen=$(( resultColumn - ${#project} - ${#testName} - 5 ))
    local padding="${ padSpaces ${padLen}; }"
    show bold "${project}" plain "test" primary "${testName}" plain "${padding}" dim warning 'â¨¯' plain dim "${message}"
}

padSpaces() {
    local count="${1:-0}"
    (( count > 0 )) && printf '%*s' "${count}" ''
}

runTest() {
    local testName="${1}"
    local testFile="${2}"
    local failedTestsFile="${3}"
    assertFileExists "${testFile}"
    local testLogFileName="${project}-${testName}.log"
    local testLogFile="${testLogDir}/${testLogFileName}"

    local padLen=$(( resultColumn - ${#project} - ${#testName} - 6 ))
    local padding="${ padSpaces ${padLen}; }"
    show -n bold "${project}" plain "test" primary "${testName}" plain "${padding}"

    (
        if [[ -x "${testFile}" ]]; then
            startSpinner "" star || fail
            if [[ ${project} == "rayvn" && ${testName} == "rayvn-up" ]]; then
                (
                    # This test needs some extra vars set as preconditions. Since all tests are executed
                    # without any rayvn vars, we need to add a couple of them back.

                    local exports=()
                    exports+=(rayvnInstallHome="${rayvnHome}")
                    exports+=(rayvnInstallBinary="${rayvnHome}/bin/rayvn")

                    # Second, export a list of the function names within the test itself so
                    # that it can ensure that no other functions are present, e.g. require

                    export testFunctionNames=${ grep -E '^\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\(\)' "${testFile}" | \
                            awk '{gsub(/\(\)/, "", $1); printf "%s ", $1}'; }
                    testFunctionNames="${testFunctionNames%" "}"

                    # Don't add an empty line at exit

                    declare -grx _noEchoOnExit=1

                    # Finally, run the test without functions or rayvn vars in its env, and without sourcing
                    # any init files.

                    executeTestFile "${testFile}" "${exports[@]}"
                ) &> "${testLogFile}"

            else
                executeTestFile "${testFile}" &> "${testLogFile}"
            fi

            stopSpinner

            if (( testResult == 0 )); then
                show " ${_greenCheckMark}" plain dim "log at ${testLogFile}"
            else
                show " ${_redCrossMark}" "log at ${testLogFile}"
                local testLogFileName="${ baseName "${testLogFile}"; }"
                echo "${testLogFileName}" >> "${failedTestsFile}"
            fi
        else
            warn "Skipping ${testFile}: not executable"
        fi
    )
}

executeTestFile() {
    local testFile="${1}"
    shift
    executeWithCleanVars "${@}" "${BASH}" --noprofile --norc "${testFile}" "${debugCommand[@]}"
    testResult=$?
}

createProject() {
    [[ "${name}" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]] || fail "sorry, '${name}' is not a valid bash identifier"
    [[ -n ${gitRoot} ]] && fail "${PWD} is within an existing project/git repo"
    local projectName="${name}"
    local projectRoot="${PWD}/${projectName}"
    assertFileDoesNotExist "${projectRoot}"
    local binDir="${projectRoot}/bin"
    local libDir="${projectRoot}/lib"
    local packageTemplate="${templateDir}/package-template.sh"
    local scriptTemplate="${templateDir}/script-template.sh"
    local libraryTemplate="${templateDir}/library-template.sh"

    echo
    show bold "Creating project '${projectName}' in" blue "'${PWD}'"
    echo

    require 'rayvn/prompt' 'rayvn/central'

    declare -i createdRepo=0
    local answer formulaFile repoUrl
    confirm "Create new GitHub repo for project '${projectName}'?" yes=default no answer || bye
    if [[ "${answer}" == "yes" ]]; then
        if ! gh auth status --active &> /dev/null; then
            confirm "Need to authenticate. Do you have a GitHub account?" y n answer || bye
            if [[ "${answer}" == "y" ]]; then
                gh auth login || exit
            else
                bye "Please go to https://github.com/ and create an account first."
            fi
        fi
        gh repo create "${projectName}" --add-readme --private --clone || fail
        cd "${projectRoot}" || fail
        repoUrl="${ git remote get-url origin; }"
        registerProjectOnRayvnCentral "${projectName}" || fail
        createdRepo=1
    else
        makeDir "${projectRoot}" > /dev/null
        cd "${projectRoot}" || fail
        git init --initial-branch=main || fail
    fi
    makeDir "${binDir}" > /dev/null
    makeDir "${libDir}" > /dev/null

    # Ok, directories are ready, copy and substitute files

    local quotedName="'${projectName}'"
    local qualifiedName="'${projectName}/example'"
    local rayvnVersion="'${ projectVersion rayvn | cut -d' ' -f2; }'"
    local libraryCall='myExampleLibraryFunction'
    local libraryName="example"
    local libraryNameInitialCap="Example"

    copyFileAndSubstituteVars "${packageTemplate}" './rayvn.pkg' quotedName rayvnVersion || fail
    copyFileAndSubstituteVars "${libraryTemplate}" './lib/example.sh' projectName quotedName qualifiedName libraryName libraryNameInitialCap || fail
    copyFileAndSubstituteVars "${scriptTemplate}" "./bin/${projectName}" quotedName qualifiedName libraryCall || fail
    chmod +x "./bin/${projectName}" || fail

    # Add and commit

    git add --all
    git commit -m "initial commit"

    # Did we create the repo?

    if (( createdRepo )); then

        # Yes, so we push the changes

        git push -u origin main || fail
        echo "New project files pushed."
        echo
    else
        echo
        show bold "Once you create a repo on GitHub, use the following commands to push it:"
        echo
        echo "   TODO: create a 'rayvn save-project' command, using initNewProjectFormulaInRayvnCentral + the following;"
        echo "   cd ${projectRoot}"
        echo "   git remote add origin https://github.com/YOUR_USER_NAME/${projectName}.git"
        echo "   git push -u origin main"
        echo
        echo
    fi
    remindIfNotInPath "${binDir}"
}

remindIfNotInPath() {
    local binDir="${1}"
    if [[ ! ":${PATH}:" == *":${binDir}:"* ]]; then
        show "Remember to add" blue "${binDir}" plain "to your PATH."
    fi
}

createScript() {
    local projectRoot projectName
    local templateFile="${templateDir}/script-template.sh"
    getProjectRoot projectRoot projectName

    local binDir="${projectRoot}/bin"
    local scriptFile="${binDir}/${name}"
    ensureDir "${binDir}"
    assertFileDoesNotExist "${scriptFile}"

    local quotedName="'${projectName}'"
    local qualifiedName=
    local libraryCall='# ...'
    copyFileAndSubstituteVars "${templateFile}" "${scriptFile}" quotedName qualifiedName libraryCall || fail

    chmod +x "${scriptFile}" || fail
    git add "${scriptFile}" || fail

    show "Created" blue "bin/${name}"
    remindIfNotInPath "${binDir}"
}

createLibrary() {
    local projectRoot projectName
    local templateFile="${templateDir}/library-template.sh"
    getProjectRoot projectRoot projectName

    local libDir="${projectRoot}/lib"
    local libraryFile="${libDir}/${name}.sh"
    ensureDir "${libDir}"
    assertFileDoesNotExist "${libraryFile}"

    local quotedName="'${projectName}'"
    local qualifiedName="'${projectName}/${name}'"
    local libraryName="${name}"
    local libraryNameInitialCap="${name^}"

    copyFileAndSubstituteVars "${templateFile}" "${libraryFile}" projectName quotedName qualifiedName libraryName libraryNameInitialCap || fail

    git add "${libraryFile}" || fail

    show "Created" blue "lib/${name}.sh"
}

createTest() {
    local projectRoot projectName
    local templateFile="${templateDir}/test-template.sh"
    getProjectRoot projectRoot projectName

    local testDir="${projectRoot}/test"
    local testFileName="test-${name}.sh"
    local testFile="${testDir}/${testFileName}"
    ensureDir "${testDir}"
    assertFileDoesNotExist "${testFile}"

    cp "${templateFile}" "${testFile}"|| fail
    chmod +x "${testFile}" || fail
    git add "${testFile}" || fail

    show "Created" blue "test/${testFileName}"
}

getProjectRoot() {
    local -n projectRootRef="${1}"
    local -n projectNameRef="${2}"

    [[ -n ${gitRoot} ]] || bye "${PWD} is not within a project/git repo"
    local _projectRoot="${gitRoot}"
    local packageFile="${_projectRoot}/rayvn.pkg"
    [[ -f "${packageFile}" ]] || bye "${_projectRoot} does not appear to be a rayvn project: no rayvn.pkg file"
    local _projectName="${ baseName ${_projectRoot}; }"
    projectRootRef="${_projectRoot}"
    projectNameRef="${_projectName}"
}

copyFileAndSubstituteVars() {
    local inputFile=${1}
    local outputFile=${2}
    local varList=("${@:3}")

    [[ -z ${inputFile} || -z ${outputFile} || ${#varList[@]} -eq 0 ]] &&
        fail "Usage: substituteVars inputFile outputFile <varName> [<varName> ...]"

    local sedExprs=()
    for varName in "${varList[@]}"; do
        local value=${!varName}
        # Escape for sed: backslash, ampersand, and delimiter /
        value=${value//\\/\\\\}
        value=${value//&/\\&}
        value=${value//\//\\/}
        sedExprs+=("-e" "s/\${${varName}}/${value}/g")
    done

    sed "${sedExprs[@]}" "${inputFile}" > "${outputFile}"
}

main "${@}"
