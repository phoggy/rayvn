#!/usr/bin/env bash
# shellcheck disable=SC2317,SC1090

# Bootstrap rayvn shared library system.
# See https://github.com/phoggy/rayvn for details.

# Verify key requirements

if ! (( BASH_VERSINFO[0] > 5 || (BASH_VERSINFO[0] == 5 && BASH_VERSINFO[1] >= 3) )); then
    echo -e "\033[0;31müî∫ rayvn requires bash version 5.2+, found ${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}.${BASH_VERSINFO[2]}\033[0m"; exit 1
else
    declare -grx osName="${ uname; }"
    declare -grx onMacOS=${ [[ ${osName} == "Darwin" ]] && echo 1 || echo 0; }
    declare -grx onLinux=${ [[ ${osName} == "Linux" ]] && echo 1 || echo 0; }
    if ! (( onMacOS || onLinux )); then
        echo -e "\033[0;31müî∫ rayvn requires either MacOS or Linux, found ${osName}\033[0m"; exit 1
    fi
    declare -grx rayvnPlatform="${osName}"
fi

require() {
    while (( ${#} > 0 )); do
        local qualifiedName="${1}"
        local projectName="${qualifiedName%/*}"
        local libraryName="${qualifiedName#*/}"
        local libraryKey="${projectName}_${libraryName}"

        # Keep a count of requests for the project and library

        (( _rayvnRequireCounts["${projectName}"]+=1 )) # note: under errexit, using ++ fails but +=1 does not!
        (( _rayvnRequireCounts["${libraryKey}"]+=1 ))

        # Have we previously loaded this library?

        if (( _rayvnRequireCounts[${libraryKey}] == 1 )); then

            # Nope, validate the request

            local failed=${_rayvnRequireFailHandler:-fail}
            local libraryRootKey="${projectName}${_libraryRootSuffix}"
            [[ -v _rayvnProjects[${libraryRootKey}] ]] || ${failed} "require '${qualifiedName}': no library root configured for rayvn project '${projectName}'"
            local libraryRoot="${_rayvnProjects[${libraryRootKey}]}"
            local libraryFile="${libraryRoot}/${libraryName}.sh"
            [[ -f ${libraryFile} ]] || ${failed} "rayvn shared library '${qualifiedName}' not found at ${libraryFile}"

            # Load the library (we can recurse here).

            _loadRayvnLibrary
        fi
        shift
    done
    return 0
}

PRIVATE_CODE="--+-+-----+-++(-++(---++++(---+( ‚ö†Ô∏è BEGIN rayvn.up PRIVATE ‚ö†Ô∏è )+---)++++---)++-)++-+------+-+--"

_loadRayvnLibrary() { # note: relies on local vars set by caller
    local initFunction="_init_${projectName}_${libraryName}"
    local loadingRayvnCore=${ [[ ${qualifiedName} == 'rayvn/core' ]] && echo 1 || echo 0; }
    local functionName hasInitFunction=0 sourceOut
    local -A newFunctions

    (( _loadLibraryDepth++ ))  # ;trace "loading '${qualifiedName}' [depth ${_loadLibraryDepth}]"

    # Load the library, capturing any output. Many of the errors that can occur here will NOT return an
    # error code, as they are considered definition-time errors rather than command execution failures, so
    # here we treat any output as an error. This means that libraries that execute code on load *and* print
    # anything will fail. Output from the init function will not fail.

    sourceOut=${ source "${libraryFile}" 2>&1; }

    if [[ -n ${sourceOut} ]]; then
        local reason=": ${sourceOut}"
        if [[ "${sourceOut}" =~ ([a-zA-Z_][a-zA-Z0-9_]*):[[:space:]]*readonly[[:space:]]+function ]]; then
            local functionName="${BASH_REMATCH[1]}"
            local source=${_rayvnFunctionSources[${functionName}]}
            if [[ ${source} != '' ]]; then
                reason="${ show ':' bold italic "${functionName}()" plain error "already defined by library '${source}'"; }"
            fi
        fi
        ${failed} "failed to load shared library '${qualifiedName}'${reason}"

    else
        # Add it to our list of sources

        _rayvnSources+=("${qualifiedName}")

        # Collect new functions

        _collectUnknownFunctionNames newFunctions

        # Process them and set all non _init_* functions readonly

        for functionName in "${!newFunctions[@]}"; do
            _rayvnFunctionSources["${functionName}"]="${qualifiedName}"
            if [[ ${functionName} == _init_* ]]; then
                [[ ${functionName} == "${initFunction}" ]] && hasInitFunction=1
            else
                declare -rf "${functionName}"
            fi
        done

        # If we found an init function, invoke (which may recurse) and remove it.

        if (( hasInitFunction )); then
            ${initFunction} || ${failed} "${initFunction}() failed"
            unset "_rayvnFunctionSources[${initFunction}]"
            unset -f "${initFunction}" || fail
        fi

        ((_loadLibraryDepth--))
    fi
}

_collectUnknownFunctionNames() {
    local -n mapRef="${1}"
    local value="${2:-1}"

    for functionName in ${ compgen -A function; }; do
        # Ignore specific functions when loading rayvn/core
        if (( loadingRayvnCore )) && [[ ${_ignoreRayvnUpFunctions[${functionName}]} != '' ]]; then
            continue
        fi
        # Ignore it if it is already known
        if [[ -v _rayvnFunctionSources[${functionName}] ]]; then
             continue
        fi
        mapRef["${functionName}"]="${value}"
    done
}

TEMPORARY_CODE="--+-+-----+-++(-++(---++++(---+( ‚ö†Ô∏è BEGIN TEMPORARY FUNCTIONS ‚ö†Ô∏è )+---)++++---)++-)++-+------+-+--"

# --- These functions will be REPLACED when rayvn/core is loaded -----------------------------------

fail() {
    printStack "${*}"
    exit 1
}

# And so will this one

printStack() {
    [[ -n ${1} ]] && echo -e "${*}\n"
    local caller=${FUNCNAME[1]}
    declare -i start=1
    declare -i depth=${#FUNCNAME[@]}
    local indent='    '
    (( depth - start == 1 )) && indent=''
    [[ ${1} ]] && { echo "${*}"; echo; }
    for ((i = start; i < depth; i++)); do
        echo "${indent}${FUNCNAME[${i}]} ${BASH_SOURCE[${i}]}:${BASH_LINENO[${i} - 1]} -> ${FUNCNAME[${i} - 1]}()"
    done
}

# --- These will be kept IFF the traceOut var is set, e.g. to another terminal or a file ----------

trace() {
    (( _tracing )) && echo -e "[trace] ${*}" > "${traceOut}"
}

traceVar() {
    if (( _tracing )) ; then
        echo > "${traceOut}"
        echo -n "[trace] " > "${traceOut}"
        declare -p "${@}" > "${traceOut}" 2> /dev/null;
        echo > "${traceOut}"
    fi
}

traceStack() {
    (( _tracing )) && printStack "[trace] ${*}" > "${traceOut}"
}

traceInit() {
    if [[ ! -v _tracing ]]; then
        if [[ -v traceOut ]]; then
            echo -e "\n\n[trace] BOOT rayvn.up --------- ${ date; } ----------------\n" > "${traceOut}"
            declare -g _tracing=1
            _rayvnFunctionSources+=(['trace']='rayvn.up' ['traceVar']='rayvn.up' ['traceStack']='rayvn.up' ['traceInit']='rayvn.up')
            trace "${1}"
        else
            declare -g _tracing=0
            _rayvnUpUnsetIds+=(trace traceVar traceStack traceInit) # remove these later
            _ignoreRayvnUpFunctions+=(['trace']=1 ['traceVar']=1 ['traceStack']=1 ['traceInit']=1)
        fi
    fi
}

# --- All the following functions will be UNSET once configuration completes, *before* any libraries are loaded --------

# bashsupport disable=BP3002
configure() {
    declare -gAx _rayvnProjects=()
    declare -gAix _rayvnRequireCounts=()
    declare -grx _projectRootSuffix='::project'
    declare -grx _libraryRootSuffix='::library'
    declare -gax _rayvnSources=() # in addition order
    declare -gA _rayvnFunctionSources=() # function name -> source map
    declare -gA _ignoreRayvnUpFunctions=()
    declare -ga _rayvnUpUnsetIds=()
    declare -g _required=()
    declare -g _loadLibraryDepth=0
    declare -gx currentProjectName
    currentProjectName=${ basename "${BASH_SOURCE[2]}"; } || fail
    currentProjectName=${currentProjectName//-/_}
    local projects=() split=() project key

    # Init tracing if traceOut is set

    traceInit "Configuring rayvn.up for project '${currentProjectName}', args: ${*}"

    # Disable and warn if any 'Unofficial Strict Mode' options are set

    if [[ -o errexit || -o pipefail || -o nounset ]]; then
        set +o errexit
        set +o pipefail
        set +o nounset
        echo "errexit, pipefail and nounset have been disabled, see https://www.reddit.com/r/bash/comments/mivbcm/comment/gt8harr/"
    fi

    # Add rayvn using *our* path to ensure we do not find a different install.
    # This is important when this file is sourced using a file path.

    local rayvnUpBinary="${BASH_SOURCE[0]}"
    rayvnUpBinary="${ dirname "${rayvnUpBinary}"; }"  # do this in 2 steps for linux
    rayvnUpBinary="${ realpath "${rayvnUpBinary}"; }"
    addProject rayvn "${ dirname "${rayvnUpBinary}"; }"

    # Unless requested, ensure that 'rayvn/core' is loaded first

    [[ -v _doNotForceRayvnCore ]] || _required+=('rayvn/core')

    # Parse args

    while (( ${#} > 0 )); do
        case "${1}" in
            -a | --add) shift; IFS=',' read -r -a split <<< "${1}"; projects+=("${split[@]}") ;;
            *) [[ "${1}" != 'rayvn/core' || -v _doNotForceRayvnCore ]] && _required+=("${1}") ;;
        esac
        shift
    done

    # Add projects, if any

    for project in "${projects[@]}"; do
        project="${project#"${project%%[![:space:]]*}"}"    # remove leading whitespace
        project="${project%"${project##*[![:space:]]}"}"    # remove trailing whitespace
        addProject "${project%%=*}" "${project#*=}"
    done

    # Set our persistent public/private functions readonly

    declare -fr require _loadRayvnLibrary _collectUnknownFunctionNames

    # Instead of enforcing library namespaces, we set all functions in each library as readonly to prevent
    # collisions. This is not truly scalable, but is reasonable for now given the very small expected user base.
    #
    # We also label each function with its source, using a map. The map enables identifying new functions after
    # sourcing a library, and only new functions are set to readonly.
    #
    # First, prepare the initial set of function sources, which are a combination of the initial environment,
    # the project that invoked us AND rayvn.up. We can't (quickly) distinguish the env from the project,
    # so we just lump them together.

    # Collect all existing functions and assign as the project source.

    _rayvnSources+=('rayvn.up' "${currentProjectName}")
    _collectUnknownFunctionNames _rayvnFunctionSources "${currentProjectName}"

    # Now replace with known sources: our persistent and replaced functions plus the debug API

    _rayvnFunctionSources+=(['require']='rayvn.up' ['_loadRayvnLibrary']='rayvn.up' ['_collectUnknownFunctionNames']='rayvn.up'
        ['fail']='rayvn/core' ['printStack']='rayvn/core'
        ['debug']='rayvn/debug' ['debugEnabled']='rayvn/debug' ['debugDir']='rayvn/debug' ['debugStatus']='rayvn/debug'
        ['debugBinary']='rayvn/debug' ['debugVars']='rayvn/debug' ['debugVarIsSet']='rayvn/debug' ['debugVarIsNotSet']='rayvn/debug'
        ['debugFile']='rayvn/debug' ['debugJson']='rayvn/debug' ['debugStack']='rayvn/debug' ['debugEnvironment']='rayvn/debug'
        ['debug']='rayvn/debug')

    # Set our temporary functions and make a copy that we can later use to unset all of them, adding temporary vars

    local rayvnUpTemporaryFunctions=(configure addRoot addProjectFromExecutable addProject)
    _rayvnUpUnsetIds+=("${rayvnUpTemporaryFunctions[@]}" _ignoreRayvnUpFunctions _required)
    [[ -v _rayvnUpKeepUnsetIds ]] || _rayvnUpUnsetIds+=(_rayvnUpUnsetIds) # keep this only if test requests


    # Collect all of our temporary functions in a map so we can ignore them when core is loaded: we do not want them
    # to become owned or readonly. Remove all of them from the initial set of sources since they will be unset.

    for key in "${rayvnUpTemporaryFunctions[@]}"; do
        _ignoreRayvnUpFunctions["${key}"]=1
        unset "_rayvnFunctionSources[${key}]"
    done

    # Finally, set flag to indicate we have completed

    declare -grx rayvnIsUp=1
}

addRoot() {
    local projectName="${1}"
    local keySuffix="${2}"
    local projectRoot="${3}"
    local key="${projectName}${keySuffix}"

    if  [[ ! -v _rayvnProjects[${key}] ]]; then
        projectRoot="${ realpath "${projectRoot}"; }" || fail "Could not resolve real path of: ${projectRoot}"
        _rayvnProjects[${key}]="${projectRoot}"

        # Define a ${project}Home var for project self reference
        [[ ${keySuffix} == "${_projectRootSuffix}" ]] && declare -grx "${projectName//-/_}Home"="${projectRoot}"
    fi
    return 0
}

addProjectFromExecutable() {
    local projectName="${1}"
    local executable="${2}"
    local path projectRoot
    path="${ type -p "${executable}"; }" || fail "'${executable}' not found for project '${projectName}'"
    path="${ realpath "${path}"; }" || fail # handle symlinks, e.g. brew style
    projectRoot="${ dirname "${path}"; }/.."
    addRoot "${projectName}" "${_projectRootSuffix}" "${projectRoot}"
}

addProject() {
    local projectName="${1}"
    local projectRoot="${2}"

    # Add project root

    if [[ -d ${projectRoot} ]]; then
        addRoot "${projectName}" "${_projectRootSuffix}" "${projectRoot}"
    else
        addProjectFromExecutable "${projectName}" "${projectRoot}"
    fi

    # Add library root if it exists

    local libraryRoot="${_rayvnProjects[${projectName}${_projectRootSuffix}]}/lib"
    if [[ -d "${libraryRoot}" ]]; then
        addRoot "${projectName}" "${_libraryRootSuffix}" "${libraryRoot}"
    fi
}

# Configure, require specified libraries, then remove all temp functions and vars.

configure "${@}"
require "${_required[@]}"
unset "${_rayvnUpUnsetIds[@]}" 2> /dev/null
return 0




